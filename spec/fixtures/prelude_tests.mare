actor Main:
  new:
    test = MicroTest
    Print.line_break // TODO: move to MicroTest constructor and finalizer
    
    ///
    // Numeric facts
    
    test["U8  bit_width"].pass = U8 .bit_width == 8
    test["U32 bit_width"].pass = U32.bit_width == 32
    test["U64 bit_width"].pass = U64.bit_width == 64
    test["I8  bit_width"].pass = I8 .bit_width == 8
    test["I32 bit_width"].pass = I32.bit_width == 32
    test["I64 bit_width"].pass = I64.bit_width == 64
    test["F32 bit_width"].pass = F32.bit_width == 32
    test["F64 bit_width"].pass = F64.bit_width == 64
    
    test["U8  is_signed"].pass = U8 .is_signed == False
    test["U32 is_signed"].pass = U32.is_signed == False
    test["U64 is_signed"].pass = U64.is_signed == False
    test["I8  is_signed"].pass = I8 .is_signed == True
    test["I32 is_signed"].pass = I32.is_signed == True
    test["I64 is_signed"].pass = I64.is_signed == True
    test["F32 is_signed"].pass = F32.is_signed == True
    test["F64 is_signed"].pass = F64.is_signed == True
    
    test["U8  is_floating_point"].pass = U8 .is_floating_point == False
    test["U32 is_floating_point"].pass = U32.is_floating_point == False
    test["U64 is_floating_point"].pass = U64.is_floating_point == False
    test["I8  is_floating_point"].pass = I8 .is_floating_point == False
    test["I32 is_floating_point"].pass = I32.is_floating_point == False
    test["I64 is_floating_point"].pass = I64.is_floating_point == False
    test["F32 is_floating_point"].pass = F32.is_floating_point == True
    test["F64 is_floating_point"].pass = F64.is_floating_point == True
    
    test["U8  bounds"].pass = U8[-1] == 255
    test["U32 bounds"].pass = U32[-1] == 4294967295
    test["U64 bounds"].pass = U64[-1] == 18446744073709551615
    test["I8  bounds"].pass = I8[-128] == 128
    test["I32 bounds"].pass = I32[-2147483648] == 2147483648
    test["I64 bounds"].pass = I64[-9223372036854775808] == 9223372036854775808
    
    ///
    // Bool convenience aliases
    
    test["True  is_true "].pass = True.is_true   == True
    test["False is_true "].pass = False.is_true  == False
    test["True  is_false"].pass = True.is_false  == False
    test["False is_false"].pass = False.is_false == True
    test["True  not     "].pass = True.not       == False
    test["False not     "].pass = False.not      == True
    
    ///
    // Numeric conversions
    
    test["U32 to u8 "].pass = U32[31].u8  == 31
    test["U32 to u32"].pass = U32[31].u32 == 31
    test["U32 to u64"].pass = U32[31].u64 == 31
    test["U32 to i8 "].pass = U32[31].i8  == 31
    test["U32 to i32"].pass = U32[31].i32 == 31
    test["U32 to i64"].pass = U32[31].i64 == 31
    test["U32 to f32"].pass = U32[31].f32 == 31
    test["U32 to f64"].pass = U32[31].f64 == 31
    test["F32 to u32"].pass = F32[31].u32 == 31
    test["F64 to u32"].pass = F64[31].u32 == 31
    test["F32 to i32"].pass = F32[31].i32 == 31
    test["F64 to i32"].pass = F64[31].i32 == 31
    
    // TODO: Test edge cases converting to and/or from floating-point numerics.
    
    ///
    // Numeric comparisons
    
    test["unsigned integer =="].pass = U32[31] == 31
    test["signed integer   =="].pass = I32[31] == 31
    test["floating point   =="].pass = F32[31] == 31
    test["unsigned integer !="].pass = U32[31] != 93
    test["signed integer   !="].pass = I32[31] != 93
    test["floating point   !="].pass = F32[31] != 93
    test["unsigned integer < "].pass = U32[31] <  93
    test["signed integer   < "].pass = I32[31] <  93
    test["floating point   < "].pass = F32[31] <  93
    test["unsigned integer <="].pass = U32[31] <= 31
    test["signed integer   <="].pass = I32[31] <= 31
    test["floating point   <="].pass = F32[31] <= 31
    test["unsigned integer > "].pass = U32[93] >  31
    test["signed integer   > "].pass = I32[93] >  31
    test["floating point   > "].pass = F32[93] >  31
    test["unsigned integer >="].pass = U32[93] >= 93
    test["signed integer   >="].pass = I32[93] >= 93
    test["floating point   >="].pass = F32[93] >= 93
    
    test["negative < positive"].pass = I32[-90] < 3
    test["positive > negative"].pass = I32[3] > -90
    
    ///
    // Numeric arithmetic
    
    test["unsigned integer +"].pass = U32[3]  + 90  == 93
    test["signed integer   +"].pass = I32[-3] + 90  == 87
    test["floating point   +"].pass = F32[9]  + 0.3 == 9.3
    test["unsigned integer -"].pass = U32[90] - 3   == 87
    test["signed integer   -"].pass = I32[90] - -3  == 93
    test["floating point   -"].pass = F32[9]  - 0.3 == 8.7
    test["unsigned integer *"].pass = U32[31] * 3   == 93
    test["signed integer   *"].pass = I32[31] * 3   == 93
    test["floating point   *"].pass = F32[31] * 0.3 == 9.3
    test["unsigned integer /"].pass = U32[93] / 10  == 9
    test["signed integer   /"].pass = I32[93] / 10  == 9
    test["floating point   /"].pass = F32[93] / 10  == 9.3
    test["unsigned integer %"].pass = U32[93] % 10  == 3
    test["signed integer   %"].pass = I32[93] % 10  == 3
    test["floating point   %"].pass = F32[93] % 10  == 3
    test["unsigned integer / by zero"].pass = U32[93] / 0 == 0
    test["signed integer   / by zero"].pass = I32[93] / 0 == 0
    test["unsigned integer % by zero"].pass = U32[93] % 0 == 0
    test["signed integer   % by zero"].pass = I32[93] % 0 == 0
    test["signed integer   / overflow"].pass = I8[-128] / -1 == 0
    test["signed integer   % overflow"].pass = I8[-128] / -1 == 0
    
    ///
    // Numeric min/max/abs
    
    test["numeric min l"].pass = U32[3].min(90) == 3
    test["numeric min r"].pass = U32[90].min(3) == 3
    test["numeric max l"].pass = U32[90].max(3) == 90
    test["numeric max r"].pass = U32[3].max(90) == 90
    test["unsigned integer abs positive"].pass = U32[93].abs == 93
    test["unsigned integer abs overflow"].pass = U32[-93].abs == -93
    test["signed integer   abs positive"].pass = I32[93].abs == 93
    test["signed integer   abs negative"].pass = I32[-93].abs == 93
    test["floating point   abs positive"].pass = F32[9.3].abs == 9.3
    test["floating point   abs negative"].pass = F32[-9.3].abs == 9.3
    
    ///
    // Integer bit manipulation
    
    test["integer invert        "].pass = U8[18].invert         == 237
    test["integer reverse_bits  "].pass = U8[18].reverse_bits   == 72
    test["integer swap_bytes U8 "].pass = U8[18].swap_bytes     == 18
    test["integer swap_bytes U32"].pass = U32[66052].swap_bytes == 67240192
    test["integer leading_zeros "].pass = U8[18].leading_zeros  == 3
    test["integer trailing_zeros"].pass = U8[18].trailing_zeros == 1
    test["integer count_ones    "].pass = U8[18].count_ones     == 2
    test["integer count_zeros   "].pass = U8[18].count_zeros    == 6
    
    Print.line_break // TODO: move to MicroTest constructor and finalizer

primitive MicroTest:
  fun "[]" (text String) MicroTestInstance:
    MicroTestInstance.new(text)

class MicroTestInstance:
  prop text String:
  new (@text):
  fun "pass=" (pass Bool):
    if pass (
      Print.f("%s", ".")
    |
      Print.line_break // TODO: fix processing of \n in string literals and use it
      Print.f("failure of '%s'!", @text)
      Print.line_break // TODO: fix processing of \n in string literals and use it
      LibPonyRT.pony_exitcode(1) // Mark the entire process as a failure.
    )

primitive Print:
  fun line_break:
    LibC.puts("".cpointer)
  
  fun f (format String, text String):
    LibC.printf(format.cpointer, text.cpointer)

ffi LibC:
  fun puts (CString) I32:
  fun printf (CString, CString) I32:

ffi LibPonyRT:
  fun pony_exitcode (I32) None:

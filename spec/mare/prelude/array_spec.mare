:import "spec"

:: A dummy class for use with identity-based equality testing.
:class ArraySpecOpaqueObject

:class ArraySpec
  :is Spec
  :const describes: "Array"
  
  :it "pushes a new element onto the end of the array and reads them back out"
    array = Array(U64).new << 3 << 6
    @assert = try (array[0]! == 3 | False)
    @assert = try (array[1]! == 6 | False)
    @assert = try (array[1]! = 12, True | False)
    @assert = try (array[1]! == 12 | False)
  
  :it "can be written as an array literal"
    array = [U8[3], U8[6], U8[12]]
    @assert = array.size == 3
    @assert = try (array[0]! == 3 | False)
    @assert = try (array[1]! == 6 | False)
    @assert = try (array[2]! == 12 | False)
    @assert = try (array[3]!, False | True)
  
  :it "allows element assignment only within the existing bounds of the array"
    array Array(U8) = [3, 6, 12]
    @assert = try (array[3]!, False | True)
    @assert = try (array[3]! = 36, False | True)
  
  :it "can be cleared to an empty size"
    array Array(U8) = [3, 6, 12]
    array.clear
    @assert = array.size == 0
    @assert = try (array[0]!, False | True)
  
  :it "compares equality for the elements in the array"
    @assert = Array(String).new == Array(String).new
    @assert = ["foo", "bar", "baz"] == ["foo", "bar", "baz"]
    @assert = ["foo", "bar", "baz"] != ["foo", "bar"]
    @assert = ["foo", "bar"] != ["foo", "bar", "baz"]
    @assert = ["foo", "bar", "baz"] != ["baz", "bar", "foo"]
    @assert = ["foo", "bar"] != ["food", "bar"]
    
  :it "returns True if the given element is equal to one already in the array"
    @assert = ["foo", "bar", "baz"].includes("foo")
    @assert = ["foo", "bar", "baz"].includes("f").not
  
  :it "returns True if the given element is pointer-identical to one in the array"
    opaque_1 = ArraySpecOpaqueObject.new
    opaque_2 = ArraySpecOpaqueObject.new
    @assert = [opaque_1].includes(opaque_1)
    @assert = [opaque_1].includes(opaque_2).not
  
  :it "yields each element in the array"
    array Array(String) = []
    ["foo", "bar", "baz"].each -> (string | array << string)
    @assert = array == ["foo", "bar", "baz"]
  
  :it "yields each element in the array, along with the index"
    array_a Array(String) = []
    array_b Array(USize) = []
    ["foo", "bar", "baz"].each_with_index -> (string, index |
      array_a << string
      array_b << index
    )
    @assert = array_a == ["foo", "bar", "baz"]
    @assert = array_b == [0, 1, 2]
  
  :it "yields each element in the array, in reverse"
    array Array(String) = []
    ["foo", "bar", "baz"].reverse_each -> (string | array << string)
    @assert = array == ["baz", "bar", "foo"]
  
  :it "yields each element in the array, in reverse, along with the index"
    array_a Array(String) = []
    array_b Array(USize) = []
    ["foo", "bar", "baz"].reverse_each_with_index -> (string, index |
      array_a << string
      array_b << index
    )
    @assert = array_b == [2, 1, 0]
    @assert =
      array_a == ["baz", "bar", "foo"]
  
  :it "returns only those elements in the array that meet the criteria"
    array Array(U8) = [11, 22, 33, 44, 36, 27, 18]
    selected = array.select -> (num | num < 30)
    @assert = selected == [11, 22, 27, 18]

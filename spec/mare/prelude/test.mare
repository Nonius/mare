:import "../micro_test" (MicroTest)

:actor Main
  :new
    test = MicroTest
    test.print_line_break // TODO: move to MicroTest constructor and finalizer
    
    ///
    // Numeric facts
    
    test["U8  bit_width"].pass = U8 .bit_width == 8
    test["U32 bit_width"].pass = U32.bit_width == 32
    test["U64 bit_width"].pass = U64.bit_width == 64
    test["I8  bit_width"].pass = I8 .bit_width == 8
    test["I32 bit_width"].pass = I32.bit_width == 32
    test["I64 bit_width"].pass = I64.bit_width == 64
    test["F32 bit_width"].pass = F32.bit_width == 32
    test["F64 bit_width"].pass = F64.bit_width == 64
    
    test["U8  is_signed"].pass = U8 .is_signed == False
    test["U32 is_signed"].pass = U32.is_signed == False
    test["U64 is_signed"].pass = U64.is_signed == False
    test["I8  is_signed"].pass = I8 .is_signed == True
    test["I32 is_signed"].pass = I32.is_signed == True
    test["I64 is_signed"].pass = I64.is_signed == True
    test["F32 is_signed"].pass = F32.is_signed == True
    test["F64 is_signed"].pass = F64.is_signed == True
    
    test["U8  is_floating_point"].pass = U8 .is_floating_point == False
    test["U32 is_floating_point"].pass = U32.is_floating_point == False
    test["U64 is_floating_point"].pass = U64.is_floating_point == False
    test["I8  is_floating_point"].pass = I8 .is_floating_point == False
    test["I32 is_floating_point"].pass = I32.is_floating_point == False
    test["I64 is_floating_point"].pass = I64.is_floating_point == False
    test["F32 is_floating_point"].pass = F32.is_floating_point == True
    test["F64 is_floating_point"].pass = F64.is_floating_point == True
    
    test["U8  bounds"].pass = U8[-1] == 0xFF
    test["U32 bounds"].pass = U32[-1] == 0xFFFF_FFFF
    test["U64 bounds"].pass = U64[-1] == 0xFFFF_FFFF_FFFF_FFFF
    test["I8  bounds"].pass = I8[-128] == 128
    test["I32 bounds"].pass = I32[-2147483648] == 2147483648
    test["I64 bounds"].pass = I64[-9223372036854775808] == 9223372036854775808
    
    ///
    // Bool convenience aliases
    
    test["True  is_true "].pass = True.is_true   == True
    test["False is_true "].pass = False.is_true  == False
    test["True  is_false"].pass = True.is_false  == False
    test["False is_false"].pass = False.is_false == True
    test["True  not     "].pass = True.not       == False
    test["False not     "].pass = False.not      == True
    
    ///
    // Numeric convenience aliases
    
    test["U32 zero"].pass = U32.zero == 0
    test["F32 zero"].pass = F32.zero == 0
    test["F64 zero"].pass = F64.zero == 0
    
    ///
    // Numeric conversions
    
    test["U32 to u8 "].pass = U32[31].u8  == 31
    test["U32 to u32"].pass = U32[31].u32 == 31
    test["U32 to u64"].pass = U32[31].u64 == 31
    test["U32 to i8 "].pass = U32[31].i8  == 31
    test["U32 to i32"].pass = U32[31].i32 == 31
    test["U32 to i64"].pass = U32[31].i64 == 31
    test["U32 to f32"].pass = U32[31].f32 == 31
    test["U32 to f64"].pass = U32[31].f64 == 31
    test["F32 to u32"].pass = F32[31].u32 == 31
    test["F64 to u32"].pass = F64[31].u32 == 31
    test["F32 to i32"].pass = F32[31].i32 == 31
    test["F64 to i32"].pass = F64[31].i32 == 31
    test["F32 to f64"].pass = F32[31].f64 == 31
    test["F64 to f32"].pass = F64[31].f32 == 31
    
    test["F32 to u8 nan       "].pass = F32.nan.u8          == 0
    test["F32 to u8 infinity  "].pass = F32.infinity.u8     == 255
    test["F32 to u8 -infinity "].pass = F32.neg_infinity.u8 == 0
    test["F32 to u8 overflow  "].pass = F32[256].u8         == 255
    test["F32 to u8 underflow "].pass = F32[-1].u8          == 0
    test["F64 to u8 nan       "].pass = F64.nan.u8          == 0
    test["F64 to u8 infinity  "].pass = F64.infinity.u8     == 255
    test["F64 to u8 -infinity "].pass = F64.neg_infinity.u8 == 0
    test["F64 to u8 overflow  "].pass = F64[256].u8         == 255
    test["F64 to u8 underflow "].pass = F64[-1].u8          == 0
    test["F32 to i8 nan       "].pass = F32.nan.i8          == 0
    test["F32 to i8 infinity  "].pass = F32.infinity.i8     == 127
    test["F32 to i8 -infinity "].pass = F32.neg_infinity.i8 == -128
    test["F32 to i8 overflow  "].pass = F32[128].i8         == 127
    test["F32 to i8 underflow "].pass = F32[-129].i8        == -128
    test["F64 to i8 nan       "].pass = F64.nan.i8          == 0
    test["F64 to i8 infinity  "].pass = F64.infinity.i8     == 127
    test["F64 to i8 -infinity "].pass = F64.neg_infinity.i8 == -128
    test["F64 to i8 overflow  "].pass = F64[128].i8         == 127
    test["F64 to i8 underflow "].pass = F64[-129].i8        == -128
    test["F64 to f32 nan      "].pass = F64.nan.f32.is_nan
    test["F64 to f32 overflow "].pass = F64.max_value.f32   == F32.infinity
    test["F64 to f32 underflow"].pass = F64.min_value.f32   == F32.neg_infinity
    
    ///
    // Numeric comparisons
    
    test["unsigned integer =="].pass = U32[31] == 31
    test["signed integer   =="].pass = I32[31] == 31
    test["floating point   =="].pass = F32[31] == 31
    test["unsigned integer !="].pass = U32[31] != 93
    test["signed integer   !="].pass = I32[31] != 93
    test["floating point   !="].pass = F32[31] != 93
    test["unsigned integer < "].pass = U32[31] <  93
    test["signed integer   < "].pass = I32[31] <  93
    test["floating point   < "].pass = F32[31] <  93
    test["unsigned integer <="].pass = U32[31] <= 31
    test["signed integer   <="].pass = I32[31] <= 31
    test["floating point   <="].pass = F32[31] <= 31
    test["unsigned integer > "].pass = U32[93] >  31
    test["signed integer   > "].pass = I32[93] >  31
    test["floating point   > "].pass = F32[93] >  31
    test["unsigned integer >="].pass = U32[93] >= 93
    test["signed integer   >="].pass = I32[93] >= 93
    test["floating point   >="].pass = F32[93] >= 93
    
    test["negative < positive"].pass = I32[-90] < 3
    test["positive > negative"].pass = I32[3] > -90
    
    ///
    // Numeric arithmetic
    
    test["unsigned integer +"].pass = U32[3]  + 90  == 93
    test["signed integer   +"].pass = I32[-3] + 90  == 87
    test["floating point   +"].pass = F32[9]  + 0.3 == 9.3
    test["unsigned integer -"].pass = U32[90] - 3   == 87
    test["signed integer   -"].pass = I32[90] - -3  == 93
    test["floating point   -"].pass = F32[9]  - 0.3 == 8.7
    test["unsigned integer *"].pass = U32[31] * 3   == 93
    test["signed integer   *"].pass = I32[31] * 3   == 93
    test["floating point   *"].pass = F32[31] * 0.3 == 9.3
    test["unsigned integer /"].pass = U32[93] / 10  == 9
    test["signed integer   /"].pass = I32[93] / 10  == 9
    test["floating point   /"].pass = F32[93] / 10  == 9.3
    test["unsigned integer %"].pass = U32[93] % 10  == 3
    test["signed integer   %"].pass = I32[93] % 10  == 3
    test["floating point   %"].pass = F32[93] % 10  == 3
    test["unsigned integer / by zero"].pass = U32[93] / 0 == 0
    test["signed integer   / by zero"].pass = I32[93] / 0 == 0
    test["unsigned integer % by zero"].pass = U32[93] % 0 == 0
    test["signed integer   % by zero"].pass = I32[93] % 0 == 0
    test["signed integer   / overflow"].pass = I8[-128] / -1 == 0
    test["signed integer   % overflow"].pass = I8[-128] / -1 == 0
    
    ///
    // Numeric min/max/abs
    
    test["numeric min l"].pass = U32[3].min(90) == 3
    test["numeric min r"].pass = U32[90].min(3) == 3
    test["numeric max l"].pass = U32[90].max(3) == 90
    test["numeric max r"].pass = U32[3].max(90) == 90
    test["unsigned integer abs positive"].pass = U32[93].abs == 93
    test["unsigned integer abs overflow"].pass = U32[-93].abs == -93
    test["signed integer   abs positive"].pass = I32[93].abs == 93
    test["signed integer   abs negative"].pass = I32[-93].abs == 93
    test["floating point   abs positive"].pass = F32[9.3].abs == 9.3
    test["floating point   abs negative"].pass = F32[-9.3].abs == 9.3
    
    ///
    // Integer bit manipulation
    
    test["integer (bits)        "].pass = U8[18]                == 0b00010010
    test["integer invert        "].pass = U8[18].invert         == 0b11101101
    test["integer reverse_bits  "].pass = U8[18].reverse_bits   == 0b01001000
    test["integer swap_bytes U8 "].pass = U8[18].swap_bytes     == 18
    test["integer swap_bytes U32"].pass = U32[66052].swap_bytes == 67240192
    test["integer leading_zeros "].pass = U8[18].leading_zeros  == 3
    test["integer trailing_zeros"].pass = U8[18].trailing_zeros == 1
    test["integer count_ones    "].pass = U8[18].count_ones     == 2
    test["integer count_zeros   "].pass = U8[18].count_zeros    == 6
    test["integer 0.next_pow2   "].pass = U8[0].next_pow2       == 1
    test["integer 2.next_pow2   "].pass = U8[2].next_pow2       == 2
    test["integer 17.next_pow2  "].pass = U8[17].next_pow2      == 32
    test["integer 127.next_pow2 "].pass = U8[127].next_pow2     == 128
    test["integer 128.next_pow2 "].pass = U8[128].next_pow2     == 128
    test["integer 129.next_pow2 "].pass = U8[129].next_pow2     == 0
    
    ///
    // Floating point bit representation and special values
    
    test["F32 bits"].pass = F32[9.3].bits == 0x4114_CCCD
    test["F64 bits"].pass = F64[9.3].bits == 0x4022_9999_9999_999A
    test["F32 from_bits"].pass = F32.from_bits(0x4114_CCCD)           == 9.3
    test["F64 from_bits"].pass = F64.from_bits(0x4022_9999_9999_999A) == 9.3
    test["F32 nan bits"].pass = F32.nan.bits == 0x7FC0_0000
    test["F64 nan bits"].pass = F64.nan.bits == 0x7FF8_0000_0000_0000
    test["F32 nan is_nan"].pass = F32.nan.is_nan
    test["F64 nan is_nan"].pass = F64.nan.is_nan
    test["F32 0 is_nan"].pass = F32[0].is_nan.is_false
    test["F64 0 is_nan"].pass = F64[0].is_nan.is_false
    test["F32 0/0 is_nan"].pass = (F32[0] / 0).is_nan
    test["F64 0/0 is_nan"].pass = (F64[0] / 0).is_nan
    test["F32 infinity bits"].pass = F32.infinity.bits == 0x7F80_0000
    test["F64 infinity bits"].pass = F64.infinity.bits == 0x7FF0_0000_0000_0000
    test["F32 neg_infinity bits"].pass = F32.neg_infinity.bits == 0xFF80_0000
    test["F64 neg_infinity bits"].pass = F64.neg_infinity.bits == 0xFFF0_0000_0000_0000
    test["F32 infinity == 1/0"].pass = F32.infinity == F32[1] / 0
    test["F64 infinity == 1/0"].pass = F64.infinity == F64[1] / 0
    test["F32 neg_infinity == -1/0"].pass = F32.neg_infinity == F32[-1] / 0
    test["F64 neg_infinity == -1/0"].pass = F64.neg_infinity == F64[-1] / 0
    test["F32 infinity is_nan"].pass = F32.infinity.is_nan.is_false
    test["F64 infinity is_nan"].pass = F64.infinity.is_nan.is_false
    test["F32 neg_infinity is_nan"].pass = F32.neg_infinity.is_nan.is_false
    test["F64 neg_infinity is_nan"].pass = F64.neg_infinity.is_nan.is_false
    test["F32 max_value is_nan"].pass = F32.max_value.is_nan.is_false
    test["F64 max_value is_nan"].pass = F64.max_value.is_nan.is_false
    test["F32 min_value is_nan"].pass = F32.min_value.is_nan.is_false
    test["F64 min_value is_nan"].pass = F64.min_value.is_nan.is_false
    test["F32 nan is_infinite"].pass = F32.nan.is_infinite.is_false
    test["F64 nan is_infinite"].pass = F64.nan.is_infinite.is_false
    test["F32 infinity is_infinite"].pass = F32.infinity.is_infinite
    test["F64 infinity is_infinite"].pass = F64.infinity.is_infinite
    test["F32 neg_infinity is_infinite"].pass = F32.neg_infinity.is_infinite
    test["F64 neg_infinity is_infinite"].pass = F64.neg_infinity.is_infinite
    test["F32 max_value is_infinite"].pass = F32.max_value.is_infinite.is_false
    test["F64 max_value is_infinite"].pass = F64.max_value.is_infinite.is_false
    test["F32 min_value is_infinite"].pass = F32.min_value.is_infinite.is_false
    test["F64 min_value is_infinite"].pass = F64.min_value.is_infinite.is_false
    test["F32 nan is_finite"].pass = F32.nan.is_finite.is_false
    test["F64 nan is_finite"].pass = F64.nan.is_finite.is_false
    test["F32 infinity is_finite"].pass = F32.infinity.is_finite.is_false
    test["F64 infinity is_finite"].pass = F64.infinity.is_finite.is_false
    test["F32 neg_infinity is_finite"].pass = F32.neg_infinity.is_finite.is_false
    test["F64 neg_infinity is_finite"].pass = F64.neg_infinity.is_finite.is_false
    test["F32 max_value is_finite"].pass = F32.max_value.is_finite
    test["F64 max_value is_finite"].pass = F64.max_value.is_finite
    test["F32 min_value is_finite"].pass = F32.min_value.is_finite
    test["F64 min_value is_finite"].pass = F64.min_value.is_finite
    
    ///
    // String methods
    
    test["String == String"].pass = ("string" == "string")
    test["String == other not"].pass = ("string" == "other").not
    test["String hash"].pass = ("string".hash == 0x4CF51F4A5B5CF110)
    
    ///
    // Array methods
    
    try (
      array_push = Array(U64).new << 9 << 3
      test["Array << <<, [0]"].pass = array_push[0]! == 9
      test["Array << <<, [1]"].pass = array_push[1]! == 3
      array_push[1]! = 33
      test["Array [1]=, [1]"].pass = array_push[1]! == 33
      (
        array_literal = [U8[0], U8[1], U8[2]]
        i U64 = 0
        while (i < 3) (
          test["Array literal, [i]"].pass = array_literal[i]! == i.u8
          i = i + 1
        )
        test["Array literal size"].pass = array_literal.size == i
        test["Array literal out of bound read error"].pass =
          try (array_literal[3]!, False | True)
        test["Array literal out of bound write error"].pass =
          try (array_literal[3]! = 3, False | True)
      )
    |
      test["Array methods test block had an out-of-bounds error"].pass = False
    )
    
    test.print_line_break // TODO: move to MicroTest constructor and finalizer

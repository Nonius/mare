:class ref Array (A)
  :prop _size USize
  :prop _alloc USize
  :prop _ptr CPointer(A)'ref
  
  :fun ref _ptr_set_null
    @_alloc = 0
    @_ptr = CPointer(A).null
  
  :fun ref _ptr_allocate (space USize)
    @_alloc = space.next_pow2.max(space).max(8)
    @_ptr = CPointer(A)._alloc(@_alloc)
  
  :fun ref _ptr_reallocate (space USize)
    @_alloc = space.next_pow2.max(space).max(8)
    @_ptr = @_ptr._realloc(@_alloc)
  
  :new (space USize = 0)
    @_size = 0
    
    if (space > 0) (
      @_ptr_allocate(space)
    |
      @_ptr_set_null
    )
  
  :fun size: @_size
  
  :fun ref clear: @_size = 0, @
  
  :fun ref reserve (space USize)
    if (@_alloc < space) \
      @_ptr_reallocate(space)
  
  :fun "[]!" (index)
    if (@size <= index) error!
    @_ptr._get_at(index)
  
  :fun ref "[]=!" (index, value)
    if (@size <= index) error!
    @_ptr._assign_at(index, --value)
  
  :fun ref "<<" (value)
    @reserve(@_size + 1)
    @_ptr._assign_at(@_size, --value)
    @_size = @_size + 1
    @
  
  :fun "!=" (other): (@ == other).not // TODO: move this to the Equatable trait?
  :fun "==" (other Array(A)'box)
    // TODO: optimize for cases when the elements can be pointer-compared by
    // value/identity instead of structural equality (e.g. Array(U8))
    equal_so_far = (@size == other.size)
    index USize = 0
    while (equal_so_far && index < @_size) (
      value_a = @_ptr._get_at(index)
      value_b = other._ptr._get_at(index)
      if (A <: Equatable(A)'read) (
        equal_so_far = (value_a == value_b)
      |
        equal_so_far = (value_a is value_b)
      )
      index = index + 1
    )
    equal_so_far
  
  :fun includes (expected A)
    is_found = False
    index USize = 0
    while (is_found.not && index < @_size) (
      actual = @_ptr._get_at(index)
      if (A <: Equatable(A)'read) (
        is_found = (actual == expected)
      |
        is_found = (actual is expected)
      )
      index += 1
    )
    is_found
  
  :fun each
    index USize = 0
    while (index < @_size) (
      yield @_ptr._get_at(index)
      index += 1
    )
    @
  
  :fun each_with_index
    index USize = 0
    while (index < @_size) (
      yield (@_ptr._get_at(index), index)
      index += 1
    )
    @
  
  :fun reverse_each
    index USize = @_size
    while (index > 0) (
      index -= 1
      yield @_ptr._get_at(index)
    )
    @
  
  :fun reverse_each_with_index
    index USize = @_size
    while (index > 0) (
      index -= 1
      yield (@_ptr._get_at(index), index)
    )
    @
  
  :fun select
    :yields for Bool
    new_array = Array(A'aliased).new // TODO: allow the caller to specify space
    index USize = 0
    while (index < @_size) (
      element = @_ptr._get_at(index)
      if (yield element) (
        new_array << element
      )
      index += 1
    )
    new_array
